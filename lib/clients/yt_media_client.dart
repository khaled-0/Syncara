import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:just_audio/just_audio.dart';
import 'package:syncara/clients/media_client.dart';
import 'package:syncara/clients/yt_transcript_fetcher.dart';
import 'package:syncara/data/models/media.dart';
import 'package:syncara/model/common.dart';
import 'package:webview_cookie_manager_plus/webview_cookie_manager_plus.dart';
import 'package:youtube_explode_dart/youtube_explode_dart.dart' as yt;

class YTMediaClient implements BaseMediaClient {
  final _httpClient = http.Client();
  final _ytClient = yt.YoutubeExplode(httpClient: YTCookieClient()).videos;
  late final _transcriptFetcher = YouTubeTranscriptFetcher(
    httpClient: _httpClient,
  );

  @override
  Future<AudioSource> getMediaSource(Media media) async {
    final streamUri = await compute(
      (data) async {
        final ytClient = data[0] as yt.StreamClient;
        final videoManifest = await ytClient.getManifest(
          data[1],
        );

        final availableManifests = List<yt.AudioStreamInfo>.of([]);
        await Future.wait([
          for (final manifest in videoManifest.audio)
            _httpClient.head(manifest.url).then((res) {
              if (res.statusCode > 299 || res.statusCode < 200) return;
              availableManifests.add(manifest);
            }),
        ]);

        return availableManifests.withHighestBitrate().url;
      },
      [_ytClient.streamsClient, media.url],
    );

    return AudioSource.uri(streamUri);
  }

  @override
  Future<List<LyricMetadata>> getAvailableLyrics(Media media) async {
    return await compute(
      (data) async {
        final fetcher = data[0] as YouTubeTranscriptFetcher;
        final availableCaptions = await fetcher.fetchAvailableCaptions(
          data[1] as String,
        );

        return availableCaptions
            .map((e) => LyricMetadata.fromYTCaption(media, e))
            .toList();
      },
      [_transcriptFetcher, media.url],
    );
  }

  @override
  Future<List<String>> getLRCLyrics(LyricMetadata meta) async {
    return await compute(
      (data) async {
        final fetcher = data[0] as YouTubeTranscriptFetcher;
        final meta = data[1] as LyricMetadata;

        final captionXml = await fetcher.fetchCaptions(
          meta.mediaID,
          languageCode: meta.langCode,
          ignoreAutogenerated: !meta.lang.contains("[Auto Generated]"),
        );
        final parsedCaptions = CaptionParser.parseXml(captionXml);
        return parsedCaptions.map((caption) {
          final lyric = caption.text.replaceAll("\n", " ");
          return "[${_formatLrcTime(caption.start)}]$lyric";
        }).toList();
      },
      [_transcriptFetcher, meta],
    );
  }

  String _formatLrcTime(double seconds) {
    final minutes = seconds ~/ 60;
    final remainingSeconds = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:'
        '${remainingSeconds.toStringAsFixed(2).padLeft(5, '0')}';
  }
}

class YTCookieClient extends yt.YoutubeHttpClient {
  /// Must be passed to isolate
  static Future<List<Cookie>> get values {
    return WebviewCookieManager().getCookies("https://youtube.com");
  }

  List<Cookie> cookies = List.of([]);

  YTCookieClient({List<Cookie> cookies = const []}) {
    this.cookies.addAll(cookies);
    this.cookies.add(Cookie("CONSENT", "YES+cb"));
  }

  @override
  Map<String, String> get headers {
    return {
      ...super.headers,
      "cookie": cookies.map((e) => e.toString()).join(";"),
    };
  }
}
